#!/bin/bash

set -e

# TOOD: Rewrite all in perl.
# TODO: Add completion helper and find from recent logs.
# TODO: Fix in_zenlog -- it won't be true if a new terminal is opened
# as a child process.

#
# zenlog:
#
# Using script, log the entire console input/output into a separate
# file for each command.
#
# Usage:
#
# zenlog [-d LOG_DIR] [-b]
#    Start a new shell, logging all the command output in a separate
#    file.
#
#    -b:  enable buffering.
#
# . <(zenlog -s)
#    Source the support commands.
#
# Sample logs are under zenlog-sample-log/.

name=$(basename "$0")

shell_helper=0
log_dir=${ZENLOG_DIR:-${TMP:-/tmp}/zenlog/}
buffering=0

while getopts "sd:b" opt; do
  case "$opt" in
    s) shell_helper=1 ;;
    d) log_dir="$OPTARG" ;;

    # enable buffering
    b) buffering=1 ;;
    *) exit 1
  esac
done
shift $(($OPTIND - 1))

if (( $shell_helper )) ; then
  cat <<'EOF'
# Show it in the prompt.  zenlog uses it to split log files.
zenlog_prompt_marker() {
  echo -e '\e[0m\e[1m\e[0m'
}

# execute command without logging output.
zenlog_iyayo() {
  echo -en '\e[0m\e[2m\e[0m'
  "${@}"
  return 1
}
alias 184=zenlog_iyayo

# Use it to echo back the entire command in pre-exec hook.
# (Optional)
zenlog_echo_command() {
  echo -en "\e[0m\e[3m\e[0m\x1b[1;36m${*}\e[0m\e[4m\e[0m"
  echo -e "\x1b[0m"
}

in_zenlog() {
  (( $IN_ZENLOG ))
}
EOF
  exit 0
fi

# Start

if (( $IN_ZENLOG )) ; then
  echo "$name: Error: already in zenlog." 1>&2
  exit 1
fi

export IN_ZENLOG=1
export log_dir
export buffering

echo "$name: Logging to $log_dir ..."

(( $buffering )) || nobuf_opt=-f

script -q $nobuf_opt >(perl -w <(cat <<'EOF'
#line 75
use strict;
use English;
use Time::HiRes qw(time);
use POSIX qw(strftime);
use File::Path qw(make_path);
use File::Basename;

my $log_dir = $ENV{log_dir};
my $buffering = $ENV{buffering};

my ($raw, $san, $raw_name, $san_name);

sub close_log() {
  $raw->close() if defined $raw;
  $san->close() if defined $san;
  undef $raw;
  undef $san;
}

my $seq = 0;
sub open_log() {
  close_log();

  my $t = time;
  my $filename = sprintf('%s/%s.%03d-%s-%d',
      $log_dir,
      strftime('%Y-%m-%d/%H:%M:%S', localtime($t)),
      ($t - int($t)) * 1000, $$, $seq++);

  make_path(dirname($filename));

  $raw_name = "${filename}-raw.log";
  $san_name = "${filename}-san.log";

  open($raw, ">$raw_name");
  open($san, ">$san_name");

  if (!$buffering) {
    $raw->autoflush();
    $san->autoflush();
  }
}

sub write_log($) {
  my ($l) = @_;
  $raw->print($l) if defined $raw;

  # Sanitize
  $l =~ s! (
        \a                           # Bell
        | \x1b \x5B .*? [\x40-\x7E]  # CSI
        | \x1b \x5D .*? \x07         # Set terminal title
        | \x1b [\x40-\x5A\x5C\x5F]   # 2 byte sequence
        )
        !!gx;
  # Also clean up CL/LFs.
  $l =~ s! \x0d+\x0a !\x0a!gx;       # Remove end-of-line CRs.
  $l =~ s! \x0d !\x0a!gx; # Replace orphan CRs with LFs.
  $san->print($l) if defined $san;
}

open_log();

while (defined(my $l = <>)) {
  # Command line and output marker.
  $l =~ s! \x1b\[0m\x1b\[3m\x1b\[0m !\nCOMMAND:\n!xg;
  $l =~ s! \x1b\[0m\x1b\[4m\x1b\[0m !\nOUTPUT:!xg;

  if ($l =~ m! ^ (.*?)  \x1b\[0m\x1b\[1m\x1b\[0m (.*) !x) {
    # separator

    my ($pre, $post) = ($1, $2);
    write_log($pre);

    open_log();

    write_log($post);

  } elsif ($l =~ m!^ (.*?) \x1b\[0m\x1b\[2m\x1b\[0m !x) {
    # 184 marker
    my ($pre) = ($1);

    write_log($pre);
    write_log("[retracted]\n");

    close_log();

  } else {
    write_log($l);
  }
}
close_log()
EOF
) )

echo "$name done." 1>&2

