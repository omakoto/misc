#!/bin/bash

set -e

# Usage:
#
# . <(zenlog -s) 
#    Source the support commands.
#
# zenlog [-d LOG_DIR]
#    Start a new shell, logging all the command output in a separate
#    file.

shell_helper=0
log_dir=${TMP:-/tmp}/zenlog/

while getopts "sd:" opt; do
  case "$opt" in
    s) shell_helper=1 ;;
    d) log_dir="$OPTARG"
  esac
done
shift $(($OPTIND - 1))

if (( $shell_helper )) ; then
  echo '
# Show it in the prompt.  It must be placed at the beginning of a 
# line.
zenlog_prompt_marker() {
  echo -e "\e[0m\e[1m\e[0m"
}

_zenlog_iyayo() {
  echo -en "\\e[0m\\e[2m\\e[0m"
  "${@}"
  return 1
}
# execute command without logging output.
alias 184=_zenlog_iyayo

# Use it to echo back the entire command in pre-exec hook.
zenlog_echo_command() {
  echo -e "\e[0m\e[3m\e[0m${*}\e[0m\e[4m\e[0m"
}
'
  exit 0
fi

script >(perl -we '   
use strict;
use English;
use Time::HiRes qw(time);
use POSIX qw(strftime);
use Getopt::Std qw(getopts);
use File::Path qw(make_path);

my $LOG_DIR = $ARGV[0];

my $out;

sub open_log() {
  $out->close() if defined $out;
 
  my $t = time;
  my $dir = sprintf("%s/%s", $LOG_DIR,
      strftime("%Y-%m-%d", localtime($t)));
  my $file = sprintf("%s.\%04d-$$.log",
      strftime("%H:%M:%S", localtime($t)),
      ($t-int($t))*10000, $$);
  make_path($dir);
  open($out, ">$dir/$file"); 
  $out->autoflush();
  print "Logging to $dir/$file...\n";
}

open_log();
while (defined(my $l = <STDIN>)) {
  # Command line and output marker.
  $l =~ s! \x1b\[0m\x1b\[3m\x1b\[0m !\nCOMMAND:\n!xg; 
  $l =~ s! \x1b\[0m\x1b\[4m\x1b\[0m !\nOUTPUT:!xg; 

  if ($l =~ m!^ \x1b\[0m\x1b\[1m\x1b\[0m !x) {
    # separator
    open_log();
  
  } elsif ($l =~ m!^ \x1b\[0m\x1b\[2m\x1b\[0m !x) {
    # 184 marker
    $out->print("[retracted]\n");
    $out->close();
    undef $out;
  }

  $out->print($l) if defined $out;
  print $l;
}
' -- "$log_dir")

