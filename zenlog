#!/bin/bash

set -e

# TOOD: Rewrite all in perl.

# Usage:
#
# . <(zenlog -s) 
#    Source the support commands.
#
# zenlog [-d LOG_DIR]
#    Start a new shell, logging all the command output in a separate
#    file.

shell_helper=0
log_dir=${TMP:-/tmp}/zenlog/

while getopts "sd:" opt; do
  case "$opt" in
    s) shell_helper=1 ;;
    d) log_dir="$OPTARG"
  esac
done
shift $(($OPTIND - 1))

if (( $shell_helper )) ; then
  cat <<'EOF'
# Show it in the prompt.  It must be placed at the beginning of a 
# line.
zenlog_prompt_marker() {
  echo -e '\e[0m\e[1m\e[0m'
}

_zenlog_iyayo() {
  echo -en '\e[0m\e[2m\e[0m'
  "${@}"
  return 1
}
# execute command without logging output.
alias 184=_zenlog_iyayo

# Use it to echo back the entire command in pre-exec hook.
zenlog_echo_command() {
  echo -e "\e[0m\e[3m\e[0m${*}\e[0m\e[4m\e[0m"
}
EOF
  exit 0
fi


export log_dir

script -f >(perl -w <(cat <<'EOF'
#line 54
use strict;
use English;
use Time::HiRes qw(time);
use POSIX qw(strftime);
use File::Path qw(make_path);
use File::Basename;

my $LOG_DIR = $ENV{log_dir};

my ($raw, $san);

sub close_log() {
  $raw->close() if defined $raw;
  $san->close() if defined $san;
  undef $raw;
  undef $san;
}

my $seq = 0;
sub open_log() {
  close_log();
 
  my $t = time;
  my $filename = sprintf("%s/%s.\%03d-%s-%d",
      $LOG_DIR,
      strftime("%Y-%m-%d/%H:%M:%S", localtime($t)),
      ($t - int($t)) * 1000, $$, $seq++);

  make_path(dirname($filename));

  open($raw, ">${filename}-raw.log"); 
  $raw->autoflush();

  open($san, ">${filename}-san.log"); 
  $san->autoflush();
}

sub write_log($) {
  my ($l) = @_;
  $raw->print($l) if defined $raw;

  # Sanitize
  $l =~ s! ( 
        \a                           # Bell
        | \x1b \x5B .*? [\x40-\x7E]  # CSI
        | \x1b \x5D .*? \x07         # Set terminal title
        | \x1b [\x40-\x5A\x5C\x5F]   # 2 byte sequence 
        )
        !!gx;
  $san->print($l) if defined $san;
}

open_log();

while (defined(my $l = <>)) {
  # Command line and output marker.
  $l =~ s! \x1b\[0m\x1b\[3m\x1b\[0m !\nCOMMAND:\n!xg; 
  $l =~ s! \x1b\[0m\x1b\[4m\x1b\[0m !\nOUTPUT:!xg; 

  if ($l =~ m! ^ (.*?)  \x1b\[0m\x1b\[1m\x1b\[0m (.*) !x) {
    # separator

    my ($pre, $post) = ($1, $2);
    write_log($pre);

    open_log();

    write_log($post);

  } elsif ($l =~ m!^ (.*?) \x1b\[0m\x1b\[2m\x1b\[0m !x) {
    # 184 marker
    my ($pre) = ($1);

    write_log($pre);
    write_log("[retracted]\n");
    
    close_log();
    continue;

  } else {
    write_log($l);
  }
}
EOF
) )
