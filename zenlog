#!/bin/bash

set -e

usage() {
  cat <<'EOF'

Zenlog

  Start a new shell where all input/output from each command will be saved
  in a separate file.

Usage:
  zenlog [-d LOG_DIR]
    Start a new shell.
 
  zenlog -p DAYS
    Purge logs older than N days and exit.

  . <(zenlog -s)
     Install the helper functions on a bash-like shell.
     Commands are:
      - zenlog_prompt_marker
          Print the command separator marker. Include it in the prompt.
          Example:
            PS1="$(zenlog_prompt_marker) > "

      - 184 COMMAND [args...]
          Run the passed command without logging the output.
          Example:
            184 emacs

      - in_zenlog
          Return success if alreay in zenlog.
          Example:
            in_zenlog && echo "in zenlog"

      - zenlog_last_log [-r]
          Print the last sanitized log filename.
          -r will print the raw log filename instead.

      - zenlog_open_last_log [-r]
          Open the last sanitized log with $ZENLOG_VIEWER or $PAGER.
          -r will open the raw log file instead.

      - zenlog_history [-r]
          Show the last N sanitized log filenames.
          -r will show the raw log filenames instead.
          
          $ZENLOG_HISTSIZE is used as the history size. (default=20)

      - zenlog_echo_command COMMAND [opts...]
          If you use this to echo back the command line that's being
          executed in the pre-exec hook, zenlog will recognize the
          current command and can perform auto-184.
          See also ZENLOG_ALWAYS_184.

  Environmental variables:
    ZENLOG_DIR
          Specify log file directory.

    ZENLOG_ALWAYS_184
          Specify executable names that shouldn't be logged.
          Needs to be used with zenlog_echo_command.
          Example: export ZENLOG_ALWAYS_184="vi emacs man"

EOF
  exit 1
}

# TOOD: Rewrite all in perl.
# TODO: Add completion helper and find from recent logs.

name=$(basename "$0")

temp=${TEMP:-${TMP:-/tmp}}
log_dir=${ZENLOG_DIR:-${temp}/zenlog}

shell_helper=0
purge_days=-1
purge_yes=0

while getopts "sd:hp:y" opt; do
  case "$opt" in
    s) shell_helper=1 ;;
    d) log_dir="$OPTARG" ;;
    p) purge_days="$OPTARG";;
    y) purge_yes=1 ;;
    *) usage;
  esac
done
shift $(($OPTIND - 1))

if (( $purge_days >= 0 )) ; then  
  if ! (( $purge_yes )) ; then
    echo -n "$name: Purging logs older than $purge_days days? (y/N) "
    read res
    [[ "$res" == "y" ]] || [[ "$res" == "Y" ]] || exit 1 
  fi
  # First, remove old log files.
  find "$log_dir" -type f -ctime +$(( $purge_days - 1 )) \
      -name '*.log' | xargs rm -f
  # Then, remove all empty directories.
  rmdir "$log_dir"/* 2>/dev/null || true
  exit 0
fi

if (( $shell_helper )) ; then
  cat <<'EOF'
# Show it in the prompt.  zenlog uses it to split log files.
zenlog_prompt_marker() {
  echo -e '\e[0m\e[1m\e[0m'
}

# execute command without logging output.
zenlog_nolog() {
  echo -en '\e[0m\e[2m\e[0m'
  "${@}"
  return 1
}
alias 184=zenlog_nolog

# Use it to echo back the entire command in pre-exec hook.
# (Optional)
zenlog_echo_command() {
  # Use $(echo) to force remove newlines.
  echo -en "\e[0m\e[3m\e[0m$(echo ${*})\e[0m\e[4m\e[0m"
  echo -e "\e[0m"
}

in_zenlog() {
  [[ "$ZENLOG_TTY" == $(tty) ]]
}

_zenlog_fail_if_not_in_zenlog() {
  if ! in_zenlog ; then
    echo "zenlog: Error: not in zenlog." 1>&2
    return 1
  fi
  return 0
}

zenlog_history() {
  _zenlog_fail_if_not_in_zenlog || return 1

  local raw=0
  local OPTIND
  while getopts "r" opt; do
    case "$opt" in
      r) raw=1 ;;
    esac
  done
  shift $(($OPTIND - 1))

  local nth="$1"

  {
    if (( $raw )) ; then
      sed -e 's/-san\.log$/-raw.log/'
    else
      cat
    fi
  } < "$ZENLOG_HISTORY" | {
    if [[ -n "$nth" ]] ; then
      tail -n $(( $nth + 1 )) | head -1
    else
      cat
    fi
  }
}

zenlog_last_log() {
  zenlog_history "${@}" 1
}

zenlog_open_last_log() {
  _zenlog_fail_if_not_in_zenlog || return 1

  local file=$(zenlog_last_log "${@}")
  if [[ -n "$file" ]] ; then
    echo "zenlog: Opening $file ..."
    ${ZENLOG_VIEWER:-$PAGER} "$file"
  fi
}

# Show the log files from the specified session (default: current
# session).
zenlog_all_session_logs() {
  _zenlog_fail_if_not_in_zenlog || return 1
  
  local pid=${1:-$ZENLOG_PID}

  find "$ZENLOG_CUR_LOG_DIR" -type f \
      -name "*-$pid-*-???.log" |
      sort -r | sed -e '/-0-raw\.log$/q'
}

zenlog_show_running_commands() {
  cat "$ZENLOG_TEMP_DIR"/zenlog-*-stat.txt
  # TODO Don't show from dead PIDs.
}

EOF
  exit 0
fi

# Start

if [[ "$ZENLOG_TTY" == $(tty) ]] ; then
  echo "$name: Error: already in zenlog." 1>&2
  exit 1
fi

export ZENLOG_TEMP_DIR="${temp}"
export ZENLOG_PID=$$
export ZENLOG_HISTORY="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-history.txt
export ZENLOG_STAT="$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-stat.txt
trap 'rm -f "$ZENLOG_TEMP_DIR"/zenlog-$ZENLOG_PID-*.txt' EXIT
: ${ZENLOG_HISTSIZE:=20}
export ZENLOG_HISTSIZE

: ${ZENLOG_ALWAYS_184:=}
export ZENLOG_ALWAYS_184

export ZENLOG_CUR_LOG_DIR=$log_dir

echo "$name: Logging to $ZENLOG_CUR_LOG_DIR ..."

# TODO: the -c part doesn't work on all shells.
script -qf \
    -c 'export ZENLOG_TTY=$(tty); $SHELL -l' \
    >(perl -w <(cat <<'EOF'
#line 232
use strict;
use Time::HiRes qw(time);
use POSIX qw(strftime);
use File::Path qw(make_path);
use File::Basename;

my $zenlog_pid = $ENV{ZENLOG_PID};
my $log_dir = $ENV{ZENLOG_CUR_LOG_DIR};
my $history_file = $ENV{ZENLOG_HISTORY};
my $history_size = $ENV{ZENLOG_HISTSIZE};
my $stat_file = $ENV{ZENLOG_STAT};

my %always_iyayo = map {$_ => 1} split(/\s+/, $ENV{ZENLOG_ALWAYS_184});

my ($raw, $san, $raw_name, $san_name);

my @history = ();

sub close_log() {
  $raw->close() if defined $raw;
  $san->close() if defined $san;
  undef $raw;
  undef $san;
}

my $seq = 0;
sub open_log() {
  close_log();

  my $t = time;
  my $filename = sprintf('%s/%s.%03d-%s-%d',
      $log_dir,
      strftime('%Y-%m-%d/%H:%M:%S', localtime($t)),
      ($t - int($t)) * 1000, $zenlog_pid, $seq++);

  make_path(dirname($filename));
 
  $raw_name = "${filename}-raw.log";
  $san_name = "${filename}-san.log";

  open($raw, ">$raw_name");
  open($san, ">$san_name");

  $raw->autoflush();
  $san->autoflush();

  push @history, $san_name;
  if (@history > $history_size) {
    @history = @history[-$history_size .. -1];
  }

  open(my $hf, ">$history_file");
  for my $h (@history) {
    print $hf ($h, "\n");
  } 
  close($hf);
}

sub write_log($) {
  return unless defined $raw;

  my ($l) = @_;
  $raw->print($l);

  # Sanitize
  $l =~ s! (
        \a                           # Bell
        | \e \x5B .*? [\x40-\x7E]  # CSI
        | \e \x5D .*? \x07         # Set terminal title
        | \e [\x40-\x5A\x5C\x5F]   # 2 byte sequence
        )
        !!gx;
  # Also clean up CL/LFs.
  $l =~ s! \s* \x0d* \x0a !\x0a!gx;       # Remove end-of-line CRs.
  $l =~ s! \s* \x0d !\x0a!gx;             # Replace orphan CRs with LFs.
  $san->print($l) if defined $san;
}

sub write_stat($) {
  my ($command) = @_;
  open(my $s, ">$stat_file");
  print $s ($zenlog_pid, "\t", ($command =~ tr!\t! !r), "\n");
  close($s);
}

sub stop_log() {
  write_log("[retracted]\n");
  close_log();
}

open_log();

while (defined(my $line = <>)) {
  # Command line and output marker.
  if ($line =~ m! \e\[0m\e\[3m\e\[0m (.*?) \e\[0m\e\[4m\e\[0m !x) {
    my $command = $1;
    write_log($line);
    write_log("COMMAND: $command\n");
    write_stat($command);

    my $exe = (split(/\s+/, $command, 2))[0];

    if (exists($always_iyayo{$exe})) {
      stop_log();
    }

    next;
  }

  if ($line =~ m! ^ (.*?)  \e\[0m\e\[1m\e\[0m (.*) !x) {
    # separator

    my ($pre, $post) = ($1, $2);
    write_log($pre);

    open_log();
    write_stat("");

    write_log($post);

    next;
  }
  if ($line =~ m!^ (.*?) \e\[0m\e\[2m\e\[0m !x) {
    # 184 marker
    my ($pre) = ($1);

    write_log($pre);
    stop_log();

    next;
  } 
  # Hack -- if a line contains 3 consecutive bells,
  # show the current filename. 
  if ($line =~ /\a\a\a\a/) {
    print("\r\n", $raw_name, "\r\n");
    
    # TODO: Maybe add another command that directly opens
    # the log with an external command.
  }

  write_log($line);
}
close_log()
EOF
) )

echo "$name done." 1>&2
