#!/bin/bash

set -e

usage() {
  cat <<'EOF'

Zenlog

  Start a new shell where all input/output from each command will be saved
  in a separate file.

Usage:
  zenlog [-d LOG_DIR] [-p DAYS]
    Start a new shell.  Options are:
       -d Specify log directory.
       -p Purge logs older than N days.

  . <(zenlog -s)
     Install the helper functions on a bash-like shell.
     Commands are:
      - zenlog_prompt_marker
          Print the command separator marker. Include it in the prompt.
          Example:
            PS1="$(zenlog_prompt_marker) > "

      - 184 COMMAND [args...]
          Run the passed command without logging the output.
          Example:
            184 adb logcat

      - in_zenlog
          Return success if alreay in zenlog.
          Example:
            in_zenlog && ceho "in zenlog"

      - zenlog_last_log [-r]
          Print the last sanitiezd log filename.
          -r will print the raw log filename.

       - zenlog_open_last_log [-r]
          Open the last logfile with $ZENLOG_VIEWER or $EDITOR.
          -r will open the raw log file.
EOF
  exit 1
}

# TOOD: Rewrite all in perl.
# TODO: Add completion helper and find from recent logs.

name=$(basename "$0")

temp=${TEMP:-${TMP:-/tmp}}
log_dir=${ZENLOG_DIR:-${temp}/zenlog}

shell_helper=0
purge_days=-1
purge_yes=0

while getopts "sd:hp:y" opt; do
  case "$opt" in
    s) shell_helper=1 ;;
    d) log_dir="$OPTARG" ;;
    p) purge_days="$OPTARG";;
    y) purge_yes=1 ;;
    *) usage;
  esac
done
shift $(($OPTIND - 1))

if (( $purge_days >= 0 )) ; then  
  if ! (( $purge_yes )) ; then
    echo -n "$name: Purging logs older than $purge_days days? (y/N) "
    read res
    [[ "$res" == "y" ]] || [[ "$res" == "Y" ]] || exit 1 
  fi
  find "$log_dir" -type d -ctime +$(( $purge_days - 1 )) -print0 | xargs -0 rm -fr
  exit 0
fi

if (( $shell_helper )) ; then
  cat <<'EOF'
# Show it in the prompt.  zenlog uses it to split log files.
zenlog_prompt_marker() {
  echo -e '\e[0m\e[1m\e[0m'
}

# execute command without logging output.
zenlog_nolog() {
  echo -en '\e[0m\e[2m\e[0m'
  "${@}"
  return 1
}
alias 184=zenlog_nolog

# Use it to echo back the entire command in pre-exec hook.
# (Optional)
zenlog_echo_command() {
  echo -en "\e[0m\e[3m\e[0m${*}\e[0m\e[4m\e[0m"
  echo -e "\x1b[0m"
}

in_zenlog() {
  [[ "$ZENLOG_TTY" == $(tty) ]]
}

_zenlog_log() {
  in_zenlog || {
    echo "zenlog: Error: not in zenlog." 1>&2
    return 1
  }
  cat "$zenlog_stat"
}

zenlog_last_log() {
  _zenlog_log | {
    if [[ "$1" == "-r" ]] ; then
      awk '{print $3}'
    else
      awk '{print $4}'
    fi
  }
}

zenlog_open_last_log() {
  local file=$(zenlog_last_log "${@}")
  if [[ -n "$file" ]] ; then
    echo "zenlog: Opening $file"
    ${ZENLOG_VIEWER:-$EDITOR} "$file"
  fi
}

EOF
  exit 0
fi

# Start

if [[ "$ZENLOG_TTY" == $(tty) ]] ; then
  echo "$name: Error: already in zenlog." 1>&2
  exit 1
fi

export log_dir

export zenlog_stat=${temp}/zenlog-stat-$$.txt
trap 'rm -f "$zenlog_stat"' EXIT

echo "$name: Logging to $log_dir ..."

# TODO: the -c part doesn't work on all shells.
script -qf \
    -c 'export ZENLOG_TTY=$(tty); $SHELL -l' \
    >(perl -w <(cat <<'EOF'
#line 124
use strict;
use Time::HiRes qw(time);
use POSIX qw(strftime);
use File::Path qw(make_path);
use File::Basename;

my $log_dir = $ENV{log_dir};
my $stat_file = $ENV{zenlog_stat};

my ($raw, $san, $raw_name, $san_name, $last_raw_name, $last_san_name);

$raw_name = "";
$san_name = "";

sub close_log() {
  $raw->close() if defined $raw;
  $san->close() if defined $san;
  undef $raw;
  undef $san;
}

my $seq = 0;
sub open_log() {
  close_log();

  my $t = time;
  my $filename = sprintf('%s/%s.%03d-%s-%d',
      $log_dir,
      strftime('%Y-%m-%d/%H:%M:%S', localtime($t)),
      ($t - int($t)) * 1000, $$, $seq++);

  make_path(dirname($filename));
 
  $last_raw_name = $raw_name;
  $last_san_name = $san_name;

  $raw_name = "${filename}-raw.log";
  $san_name = "${filename}-san.log";

  open($raw, ">$raw_name");
  open($san, ">$san_name");

  $raw->autoflush();
  $san->autoflush();

  open(my $stat, ">$stat_file"); 
  print $stat "$raw_name $san_name $last_raw_name $last_san_name";
  close($stat);
}

sub write_log($) {
  my ($l) = @_;
  $raw->print($l) if defined $raw;

  # Sanitize
  $l =~ s! (
        \a                           # Bell
        | \x1b \x5B .*? [\x40-\x7E]  # CSI
        | \x1b \x5D .*? \x07         # Set terminal title
        | \x1b [\x40-\x5A\x5C\x5F]   # 2 byte sequence
        )
        !!gx;
  # Also clean up CL/LFs.
  $l =~ s! \s* \x0d* \x0a !\x0a!gx;       # Remove end-of-line CRs.
  $l =~ s! \s* \x0d !\x0a!gx;             # Replace orphan CRs with LFs.
  $san->print($l) if defined $san;
}

open_log();

while (defined(my $l = <>)) {
  # Command line and output marker.
  $l =~ s! \x1b\[0m\x1b\[3m\x1b\[0m !\nCOMMAND:\n!xg;
  $l =~ s! \x1b\[0m\x1b\[4m\x1b\[0m !\nOUTPUT:!xg;

  if ($l =~ m! ^ (.*?)  \x1b\[0m\x1b\[1m\x1b\[0m (.*) !x) {
    # separator

    my ($pre, $post) = ($1, $2);
    write_log($pre);

    open_log();

    write_log($post);

  } elsif ($l =~ m!^ (.*?) \x1b\[0m\x1b\[2m\x1b\[0m !x) {
    # 184 marker
    my ($pre) = ($1);

    write_log($pre);
    write_log("[retracted]\n");

    close_log();

  } else {
    write_log($l);
  }
}
close_log()
EOF
) )

echo "$name done." 1>&2
